# simd-minimizers-cpp

> *This README was generated by Claude Opus 4.5*

A SIMD-accelerated C++ library to compute random minimizers for DNA sequences.

> C++ port of [simd-minimizers](https://github.com/RagnarGrootKoerkamp/simd-minimizers) (Rust). This fork keeps the Rust code but focuses on the standalone C++ implementation.

The library can compute all minimizers of a human genome in ~4 seconds using a single thread. It also provides a *canonical* version that ensures a sequence and its reverse-complement always select the same positions.

The underlying algorithm is described in:

- **SimdMinimizers: Computing random minimizers, fast.**
  Ragnar Groot Koerkamp, Igor Martayan
  SEA 2025 [doi.org/10.4230/LIPIcs.SEA.2025.20](https://doi.org/10.4230/LIPIcs.SEA.2025.20)

## Features

- **AVX2 SIMD acceleration**: 8-way parallelism for high throughput
- **Canonical minimizers**: Strand-independent positions (forward = reverse-complement)
- **2-bit packed sequences**: Efficient memory representation (4 bases per byte)
- **Rolling ntHash**: Fast O(1) per-kmer hash computation

## Requirements

- **x86-64 with AVX2** (Intel Haswell+ or AMD Excavator+)
- **C++17** compatible compiler
- **Clang recommended** for best performance (matches Rust/LLVM optimization)
- GCC works but may be 10-20% slower

## Quick Start

### Integration into Your Project

Copy these files into your project:

```
src/canonical_minimizers.hpp    # Main API header
src/packed_seq.hpp              # 2-bit DNA packing + SIMD iteration
src/canonical_minimizers_simd.cpp   # AVX2 implementation
src/canonical_minimizers_scalar.cpp # Scalar reference implementation
```

Compile with:

```bash
clang++ -std=c++17 -O3 -mavx2 -march=native \
    -c canonical_minimizers_simd.cpp canonical_minimizers_scalar.cpp
```

### Usage Example

```cpp
#include "canonical_minimizers.hpp"
#include "packed_seq.hpp"
#include <vector>
#include <cstdio>

int main() {
    // DNA sequence (ASCII)
    const char* dna = "ACGTGCTCAGAGACTCAGAGGAACGTACGT";
    size_t len = strlen(dna);

    // Pack into 2-bit representation
    auto seq = packed_seq::PackedSeq::from_ascii(
        reinterpret_cast<const uint8_t*>(dna), len);

    // Parameters
    uint32_t k = 15;  // k-mer size
    uint32_t w = 10;  // window size

    // Compute canonical minimizers
    uint32_t* positions;
    uint32_t num_positions;
    canonical_minimizers_seq_simd_avx2(
        seq.data(), seq.len(), k, w,
        &positions, &num_positions);

    // Print results
    printf("Found %u minimizers:\n", num_positions);
    for (uint32_t i = 0; i < num_positions; i++) {
        printf("  position %u\n", positions[i]);
    }

    // Free allocated memory
    free_minimizers(positions);
    return 0;
}
```

### Building Standalone

A Makefile is provided for standalone builds:

```bash
make check    # Compile check only
make          # Build test executable
make clean    # Clean build artifacts
```

Or compile directly:

```bash
g++ -std=c++17 -O3 -mavx2 -march=native \
    -o test_minimizers \
    src/canonical_minimizers_simd.cpp \
    src/canonical_minimizers_scalar.cpp \
    -DTEST_MAIN
```

## API Reference

### Main Functions

```cpp
// Compute canonical minimizer positions (SIMD, AVX2)
// Allocates output array - caller must call free_minimizers()
void canonical_minimizers_seq_simd_avx2(
    const uint8_t* seq_data,   // Packed 2-bit sequence data
    uint32_t seq_len,          // Sequence length in bases
    uint32_t k,                // k-mer size
    uint32_t w,                // Window size
    uint32_t** out_ptr,        // Output: pointer to positions array
    uint32_t* out_len          // Output: number of positions
);

// Free memory allocated by canonical_minimizers_seq_simd_avx2
void free_minimizers(uint32_t* ptr);
```

### Packed Sequence Utilities

```cpp
namespace packed_seq {
    class PackedSeq {
        // Create from ASCII DNA (ACTG/actg)
        static PackedSeq from_ascii(const uint8_t* ascii, size_t len);

        // Access
        size_t len() const;
        const uint8_t* data() const;
        uint8_t get(size_t i) const;  // Get base at position (0-3)
    };
}
```

## Performance

When compiled with Clang and `-O3 -mavx2 -march=native`, the C++ implementation achieves performance competitive with the Rust version:

| Pipeline | Throughput |
|----------|------------|
| Non-canonical | ~450 MB/s |
| Canonical | ~300 MB/s |

**Note**: GCC produces slower code (~10-20% slower). Use Clang for best performance.

## Algorithm Overview

The implementation uses 8-way SIMD parallelism:

1. **Split** input sequence into 8 chunks
2. **Compute rolling ntHash** (32-bit) for each k-mer using AVX2
3. **Sliding window minimum** on hash values (two-stack algorithm)
4. **Deduplicate** consecutive equal positions
5. **Collect** results from all 8 chunks

For canonical minimizers, the algorithm additionally:
- Computes XOR of forward and reverse-complement hashes
- Tracks both leftmost and rightmost minimum positions
- Uses TG-count to determine "preferred" strand for tie-breaking

## Citation

If you use this library in your research, please cite:

```bibtex
@inproceedings{simdminimizers2025,
  author    = {Groot Koerkamp, Ragnar and Martayan, Igor},
  title     = {SimdMinimizers: Computing Random Minimizers, Fast},
  booktitle = {SEA 2025},
  year      = {2025},
  doi       = {10.4230/LIPIcs.SEA.2025.20}
}
```

## License

Same license as the original simd-minimizers Rust library.
